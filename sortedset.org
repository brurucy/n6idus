#+title: Pseudo-differential dataflow in JS
#+author: Rucy
#+date: 2021-07-08
#+STARTUP: latexpreview

* TOC [66%]
** DONE Prelude
** DONE Background: RDF, RDFS and Inference
** TODO Hands-on: Writing the Join Operator [0%]
*** TODO Join key equality
**** TODO Tests
**** TODO Implementation
*** TODO Merge-sort join
**** TODO Tests
**** TODO Implementation

* Prelude
  
  I've been spending quite a considerable amount of time with Differential Dataflow, a general computing framework. There are 300 introductions to it,
  written by ~~Lord~~ McSherry himself, the *creator*, so I'm not explaining it here. Nevertheless, see it as flink but without any sort of fault tolerance,
  hence faster, and written in *rust* +that fact alone makes it better than all other alternatives+.

  I've recently had the opportunity to start working as a DevOps Engineer, and, to my surprise, their main programming language is...Javascript. There are
  *one gorillon* javascript books, tutorials and else; It's very overwhelming. I settled for reading the [[https://www.amazon.com/Modern-JavaScript-Impatient-Cay-Horstmann/dp/0136502148][Javascript for the Impatient book]], which was great. The logical
  progression, after finishing the book, would be to indeed get hands on with javascript, so, I *tried* to implement a *Graph Materialization* library inspired on
  differential dataflow.

* Background

  Before we tackle on what graph materialization is, let's first start by describing our data structure.

** RDF

   RDF is a data format in which data is represented as a multigraph, that is, a graph in which there can be more than one edge between two nodes. 

   Every data point is defined as a triple ==(subject, predicate, object)==, where ==predicate== can be either ==type==, indicating that ==subject== is of ==type== ==object==
   or a ==property==, meaning that the ==subject== is in some ==property== relationship to the ==object==.

   The most popular RDF file type is ==.nt== in which each row is a triple.

   As an example, let's take the following multigraph:

   #+BEGIN_EXAMPLE

   (javascript, type, interpreted)
   (javascript, type, dynamic)
   (interpreted, subClassOf, language)
   (dynamic, subClassOf, weaklyTyped)

   #+END_EXAMPLE

   We can understand it like this:

   Javascript is both interpreted and dynamic. If something is interpreted, then it is a language, and in case it is dynamic, then it is weakly typed.

   And visualized as follows:

*** TODO Multigraph viz with D3.js

    From the javascript node we have two edges to interpreted and dynamic, asserting that javascript has these two characteristics. Assertions of this kind are said to belong to the
    Abox, the box of assertional axioms. The other box, Tbox, that has terminological axioms, is where the nodes connected by edges such as ==subClassOf== are in. Think of the Abox
    as the actual data, and the Tbox as what actually gives the meaning to the data. Usually the Tbox is much smaller than the Abox.
    
** RDFS

   However, take a look at the multigraph again. If one were to query it, in the most naive way as possible, merely pattern matching, as to whether javascript is a language or not,
   it would say that it isn't, since even though we've defined its meaning, it hasn't been *materialized*, that is, inferred, literally added to the Abox, yet.

   RDFS, in a nutshell, is a collection of predicates for RDF that allows you to define richer semantics for reasoning. For instance, with regular RDF all we have are type and property
   assertions, that have no reasoning power at all. In the multigraph example, we have =subClassOf=, which is actually from rdfs, and in case one were to materialize that multigraph
   we would have two new triples added, =(javascript, type, language)= and =(javascript, type, weaklyTyped)=, effectively *saturating* the multigraph.

** RDFS Inference

   Okay, now that RDF and RDFS are defined, how does inference /really/ happens?. The act of inference is described by rules, and are usually very simple. For instance, transitive
   chains of =subClassOf= could be materialized with the following rule:

   #+BEGIN_EXAMPLE
   [a, subClassOf, c] <- [a, subClassOf, b], [b, subClassOf, c]
   #+END_EXAMPLE
   
   This syntax is called *Datalog* syntax, and can be read as follows: "If a is a subclass of b, and b is a subclass of c, then a is a subclass of c". the commas that separate the elements
   of the rule's *body*, the right side of the arrow, are interpreted as "and".

   If the predicates in the rule *body* are satisfied, then a new triple will be added.
   
   However, how would we actually *code* that?

   An intuitive take is to try to translate these rules to series of *join*, *map* and *filter* applications. For instance, that example rule could be written like this, in pseudo-js:

   #+BEGIN_EXAMPLE
   function(data) {

     let sco_assertions = data
       .filter((s, p, o) => p == "subClassOf");
   
     let data_by_subject = sco_assertions
       .map((s, p, o) => (s, o));
     let data_by_object = sco_assertions
       .map((s, p, o) => (o, s));

     return data_by_object
       .join(data_by_subject)

   }
   #+END_EXAMPLE

   If we were to apply this function until no more new triples could be derived, we would get the expected saturation.
   
* Hands-on

   Now that we know how *everything* works, let's start out from the very basics, by first implementing the join operator.

   We need the following thingsies:

   1. A way to sort the triples
   2. A way to compare keys(joins will not always be over unary keys, for instance, maybe you want to join over subjects *and* predicates)
   3. An implementation of merge-join

   Let us define an order for triples:

   1. A triple $\leq$ itself.
   2. If a.0 $\leq$ b.0 and b.0 $\leq$ a.0, then we compare the next triple constituent.
   3. If a.0 $\leq$ b.0 and b.0 $\leq$ a.0, and there are no more triples to compare, then true.
   4. If a.x $\leq$ b.x, then a $\leq$ b.

   Cool, now let's write some tests. I'll use the [[https://jestjs.io][jest]] testing framework because....uhm, it seems to be the most hyped one.

   
  
